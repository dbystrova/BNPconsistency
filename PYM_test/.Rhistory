weights_PYM<- mult_PY(alpha,sigma,H)
c <- sample(1:H,size=ns, replace=TRUE, prob=weights_PYM )
n_c<- length(unique(c))
array_nc[i]<- n_c
i=i+1
}
p_k = tibble(k=as.numeric(names(table(array_nc))),
p_k=as.vector(table(array_nc))/sum(table(array_nc)))
p_zeros= tibble(k=(1:H)[!1:H%in%p_k$k],
p_k=rep(0,length((1:H)[!1:H%in%p_k$k])))
return(rbind(p_k, p_zeros))
}
incltxt <- '
double reccursive_Cnk(const int n, const int k, const double sigma) {
if (k == 0) {
if ( n == 0) {
return(1);
}
else{
return (0);
}
}
else{
if (k>n){
return(0);
}
else{
return((n - 1 - sigma*k)*reccursive_Cnk(n-1, k, sigma) + sigma*reccursive_Cnk(n-1, k-1, sigma));
}
}
}'
Cnk_Rcpp <- cxxfunction(signature(ns="integer", ks="integer", sigmas ="numeric"),
plugin="Rcpp",
incl=incltxt,
body='
int n = Rcpp::as<int>(ns);
int k = Rcpp::as<int>(ks);
float sigma= Rcpp::as<float>(sigmas);
return Rcpp::wrap( reccursive_Cnk(n,k,sigma));
')
pdf_lk<- function(l,v, n_k, sigma,H){
return( ((v/H)^l)*Cnk_Rcpp(n_k,l,sigma))
}
pdf_lk_mat<- function(l,v, n_k, sigma,H, mat){
return( (v^l)*exp(mat[n_k,l]))
}
sample_lk<- function(nk_vec,v,sigma,H){
l_post<-c()
k<- length(nk_vec)
for (i in 1:k){
l_vec<- 1:nk_vec[i]
if (length(l_vec)==1){
l_post[i]=l_vec
}
else{
p_v<- sapply(l_vec, function(x) pdf_lk(x,v,nk_vec[i],sigma,H))
pv_norm<- p_v/sum(p_v)
l_post[i]<- sample(1:(nk_vec[i]),size=1, replace=TRUE, prob=pv_norm)
}
}
return(l_post)
}
sample_lk_mat<- function(nk_vec,v,sigma,H,M){
l_post<-c()
k<- length(nk_vec)
for (i in 1:k){
l_vec<- 1:nk_vec[i]
if (length(l_vec)==1){
l_post[i]=l_vec
}
else{
p_v<- sapply(l_vec, function(x) pdf_lk_mat(x,v,nk_vec[i],sigma,H,mat=M))
pv_norm<- p_v/sum(p_v)
l_post[i]<- sample(1:(nk_vec[i]),size=1, replace=TRUE, prob=pv_norm)
}
}
return(l_post)
}
ptr_N01 <- create_xptr("log_v_pdf_C")
ptr_logv_mat <- create_xptr("log_v_pdf_mat")
read.dta <- function()
{
X <- read.table("EIG.txt",header=1)
y <- X$recorded
y <- log( y[!is.na(y)] )  # log EIG121 expression
n <- length(y)
return(dta=list(y=y, n=n))
}
a <- 2.5;   b <- 0.1     # 1/sig ~ Ga(a,b)
m0 <- 0;  B0 <- 1000    # G0 = N(m0,B0)
M <- 1
alpha=1
sigma=0.25
H <- 20
init.DPk <- function()
{ ## inital EDA estimate of G = sum_{h=1..10} w_h delta(m_h)
## returns:
##   list(mh,wh)
## use (mh,wh) to initialize the blocked Gibbs
## cluster data, and cut at height H=10, to get 10 clusters
hc <- hclust(dist(y)^2, "cen")
r  <- cutree(hc, k = 20)
## record cluster specific means, order them
mh1 <- sapply(split(y,r),mean)    # cluster specific means == m_h
wh1 <- table(r)/n
idx <- order(wh1,decreasing=T)    # re-arrange in deceasing order
mh <- mh1[idx]
wh <- wh1[idx]
return(list(mh=mh,wh=wh,r=r))
}
julia <- julia_setup()
julia_library("DataFrames")
julia_library("GibbsTypePriors")
julia_installed_package("DataFrames")
julia_library("DataFrames")
julia_install_package_if_needed("DataFrames")
julia_library("DataFrames")
# = Define a function in Julia for a linear regression = #
julia_command("
function compute_Cnk_matrix(n, H, σ)
Cnk_matrix = Array{Float64}(undef,n,n )
for j in (1:n)
for l in (1:n)
if (l<= j)
Cnk_matrix[j,l] =  log(Cnk(j, l, σ)) - l* log(RR(H))|> Float64
end
if (l> j)
Cnk_matrix[j,l] = 0
end
end
end
return Cnk_matrix
end
")
julia_call("compute_Cnk_matrix", 20, 10, 0.5)
julia_install_package_if_needed("DataFramesMeta")
julia_library("DataFramesMeta")
# = Define a function in Julia for a linear regression = #
julia_command("
function compute_Cnk_matrix(n, H, σ)
Cnk_matrix = Array{Float64}(undef,n,n )
for j in (1:n)
for l in (1:n)
if (l<= j)
Cnk_matrix[j,l] =  log(Cnk(j, l, σ)) - l* log(RR(H))|> Float64
end
if (l> j)
Cnk_matrix[j,l] = 0
end
end
end
return Cnk_matrix
end
")
julia_call("compute_Cnk_matrix", 20, 10, 0.5)
julia_call("compute_Cnk_matrix", 20, 10.0, 0.5)
julia_call("compute_Cnk_matrix",112,112,0.5)
julia_assign("n", 20)
julia_assign("H", 10)
julia_assign("σ", 0.5)
round(julia_eval("compute_Cnk_matrix(n, H, σ)",3))
round(julia_eval("compute_Cnk_matrix(n, H, σ)"),3)
julia_eval("compute_Cnk_matrix(n, H, σ)")
# = Define a function in Julia for a linear regression = #
julia_command("
function compute_Cnk_matrix(n, H, σ)
Cnk_matrix = Array{Float64}(undef,n,n )
for j in (1:n)
for l in (1:n)
if (l<= j)
Cnk_matrix[j,l] =  log(Cnk(j, l, σ)) - l* log(RR(H))|> Float64
end
if (l> j)
Cnk_matrix[j,l] = 0
end
end
end
return Cnk_matrix
end
")
n=20
l = list()
i=1
j=1
julia_assign("j", i)
julia_assign("l", j)
julia_assign("H", 10)
julia_assign("σ", 0.5)
lik = matrix(0,n,n )
lik[i,j]= julia_eval( " log(Cnk(j, l, σ)) - l* log(RR(H))|> Float64")
julia_library("GibbsTypePriors")
lik[i,j]= julia_eval( " log(Cnk(j, l, σ)) - l* log(RR(H))|> Float64")
lik[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) - l* log(RR(H))|> Float64")
install.packages("GibbsTypePriors")
# install.packages("devtools")
devtools::install_github("konkam/RGibbsTypePriors")
# install.packages("devtools")
devtools::install_github("konkam/RGibbsTypePriors")
julia <- julia_setup()
julia_install_package_if_needed("DataFrames")
julia_install_package_if_needed("DataFramesMeta")
julia_library("GibbsTypePriors")
julia_library("DataFrames")
julia_library("DataFramesMeta")
n=20
l = list()
lik = matrix(0,n,n )
julia_assign("j", i)
julia_assign("l", j)
julia_assign("H", 10)
julia_assign("σ", 0.5)
lik[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) - l* log(RR(H))|> Float64")
lik[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) - l* log(H)|> Float64")
julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) ")
julia_eval( " log(GibbsTypePriors.Cnk(10, 5, 0.1)) ")
julia_eval( " log(GibbsTypePriors.Cnk(10, 5, 0.1))|> Float64")
julia_eval( " log(GibbsTypePriors.Cnk(10, H, 0.1))|> Float64")
julia_eval( " log(GibbsTypePriors.Cnk(10, 0.5, 0.1))|> Float64")
julia_eval( " log(GibbsTypePriors.Cnk(10, 0.5, 0.1))|> Float64")
julia_eval("log(GibbsTypePriors.Cnk(10, 5, 0.1))|> Float64")
julia_eval("log(GibbsTypePriors.Cnk(10, H, 0.1))|> Float64")
julia_eval("log(GibbsTypePriors.Cnk(10, $K, 0.1))|> Float64")
julia_eval("log(GibbsTypePriors.Cnk(10, j, 0.1))|> Float64")
type(j)
typeof(j)
typeof(as.integer(j))
julia_assign("j", as.integer(i))
julia_assign("l", as.integer(i))
julia_eval("log(GibbsTypePriors.Cnk(10, j, 0.1))|> Float64")
lik[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) - l* log(H)|> Float64")
lik[i,j]
n=20
l = list()
lik = matrix(0,n,n )
for (i in 1:n){
for (j in 1:n){
if (j<=i){
julia_assign("j", as.integer(i))
julia_assign("l", as.integer(i))
julia_assign("H", as.integer(10))
julia_assign("σ", 0.5)
julia_eval("log(GibbsTypePriors.Cnk(10, j, 0.1))|> Float64")
lik[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) - l* log(RR(H))|> Float64")
}
}
}
n=20
l = list()
lik = matrix(0,n,n )
for (i in 1:n){
for (j in 1:n){
if (j<=i){
julia_assign("j", as.integer(i))
julia_assign("l", as.integer(i))
julia_assign("H", as.integer(10))
julia_assign("σ", 0.5)
lik[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) - l* log(H)|> Float64")
}
}
}
lik
n=20
l = list()
lik = matrix(0,n,n )
for (i in 1:n){
for (j in 1:n){
if (j<=i){
julia_assign("j", as.integer(i))
julia_assign("l", as.integer(j))
julia_assign("H", as.integer(10))
julia_assign("σ", 0.5)
lik[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(j, l, σ)) - l* log(H)|> Float64")
}
}
}
lik
compute_matrix<- function(n, sigma, K){
Mat  = matrix(0,n,n )
for (i in 1:n){
for (j in 1:n){
if (j<=i){
julia_assign("i", as.integer(i))
julia_assign("j", as.integer(j))
julia_assign("H", as.integer(K))
julia_assign("σ", sigma)
Mat[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(i, j, σ)) - l* log(H)|> Float64")
}
}
}
return (Mat)
}
compute_matrix<- function(n, sigma, K){
Mat  = matrix(0,n,n )
for (i in 1:n){
for (j in 1:n){
if (j<=i){
julia_assign("i", as.integer(i))
julia_assign("j", as.integer(j))
julia_assign("H", as.integer(K))
julia_assign("σ", sigma)
Mat[i,j]= julia_eval( " log(GibbsTypePriors.Cnk(i, j, σ)) - l* log(H)|> Float64")
}
}
}
return (Mat)
}
ptr_N01 <- create_xptr("log_v_pdf_C")
ptr_logv_mat <- create_xptr("log_v_pdf_mat")
c<- c(1/4,1/8,1/4,1/8,1/4)
mu<-c(-2,-1, 0, 1, 2)
sd<- c(0.2,0.2, 0.2,0.2, 0.2)
plot(1:5,c, ylim=c(0,1))
N<-3000
components<- sample(1:5, prob=c, size=N, replace=TRUE)
mu<-c(-2,-1, 0, 1, 2)
sigma_vec<- sd
samples<- rnorm(n=N, mean=mu[components],sd=sigma_vec[components])
plot(density(samples))
#dta$y <- samples
#dta$n<- N
#attach(dta)
y <- samples
n <- N
mat = compute_matrix(n, sigma, H)
N<-30
c<- c(1/4,1/8,1/4,1/8,1/4)
mu<-c(-2,-1, 0, 1, 2)
sd<- c(0.2,0.2, 0.2,0.2, 0.2)
plot(1:5,c, ylim=c(0,1))
N<-30
components<- sample(1:5, prob=c, size=N, replace=TRUE)
mu<-c(-2,-1, 0, 1, 2)
sigma_vec<- sd
samples<- rnorm(n=N, mean=mu[components],sd=sigma_vec[components])
plot(density(samples))
#dta$y <- samples
#dta$n<- N
#attach(dta)
y <- samples
n <- N
mat = compute_matrix(n, sigma, H)
G <- init.DPk()
sig <- 0.11
## data structures to save imputed F ~ p(F | ...)
#xgrid <- seq(from= -10, to=2,length=50) for ex1
xgrid <- seq(from= -4, to=4,length=50)  #for ex2
fgrid <- NULL
plot(density(y),xlab="X",ylab="Y",bty="l",type="l",
xlim=c(-4, 4),ylim=c(0,0.4), main="")
#xlim for ex1 c(-10, 2)
## Gibbs
k_vec<-c()
itre =1
iter = 1
G$r <-  sample.r(G$wh,G$mh,sig)   # 1. r_i ~ p(r_i | ...), i=1..n
G$mh <- sample.mh(G$wh,G$r,sig)   # 2. m_h ~ p(m_h | ...), h=1..H
r
sample.mh <- function(wh,r,sig)
{ ## sample mh ~ p(mh | ...)
##
mh <- rep(0,H)     # initialize
for(h in 1:H){
if(any(r==h)){      # some data assigned to h-th pointmass
Sh <- which(r==h) # Sh = {i: r[i]=h
nh <- length(Sh)
ybarh <- mean(y[Sh])
varh   <- 1.0/(1/B0 + nh/sig^2)
meanh  <- varh*(1/B0*m0 + nh/sig^2*ybarh)
} else {            # no data assinged to h-th pointmass
varh  <- B0       # sample from base measure
meanh <- m0
}
mh[h] <- rnorm(1,m=meanh,sd=sqrt(varh))
}
return(mh)
}
### This is DP multinomial variant
sample.vh <- function(r)
{## sample vh ~ p(vh | ...)
## returns: wh
vh <- rep(0,H)  # initialize
wh <- rep(0,H)
V <-  1         # record prod_{g<h} (1-vh_h)
for(h in 1:(H-1)){
Ah <- which(r==h)
Bh <- which(r>h)
vh[h] <-  rbeta(1, 1+length(Ah), M+length(Bh))
wh[h] <- vh[h]*V
V <- V*(1-vh[h])
}
vh[H] <- 1.0
wh[H] <- V
return(wh)
}
## This is PY multinomial version
sample.vh2 <- function(r){
## sample vh ~ p(vh | ...)
## returns: wh
#r=c
n_k<- table(r)
lh<-  rep(0,H)
#sample v
v_s = ru_rcpp(logf = ptr_logv_mat,alpha=alpha, sigma=sigma,H=H,k = length(n_k), nk_vec=n_k,Cnk_mat=M2, n=1,  d=1, init=1)
#sample lk
lk <- sample_lk_mat(n_k,v_s$sim_vals[1],sigma,H,M2)
lh[c(as.numeric(c(names(n_k))))]= lk
vh <- rep(0,H)  # initialize
W_h <- rep(0,H)
P_h<-  rep(0,H)
p_vec<- n_k - lk*sigma
W_h<- rdirichlet(1,c(p_vec, sum(lk)*sigma + alpha))
### R
alpha_post<- alpha + sum(lk)*sigma
Uv<- rgamma(1,alpha_post/sigma,alpha_post/sigma)
U<- (Uv)^(1/sigma)
x.rlap <- rlaptrans(H, lt.temp_st_pdf, c=alpha_post/(sigma*H), sigma, k=U)
R_h<- x.rlap /sum(x.rlap)
P_h[c(as.numeric(c(names(n_k))))]<- W_h[1:length(n_k)] + W_h[length(n_k)]* R_h[1:length(n_k)]
P_h[-c(as.numeric(c(names(n_k))))] <-  W_h[length(n_k)]* R_h[(length(n_k)+1):H]
return(P_h)
}
n_k = table(G$r)
v_s = ru_rcpp(logf = ptr_logv_mat,alpha=alpha, sigma=sigma,H=H,k = length(n_k), nk_vec=n_k,Cnk_mat=M2, n=1,  d=1, init=1)
ptr_N01 <- create_xptr("log_v_pdf_C")
ptr_logv_mat <- create_xptr("log_v_pdf_mat")
ptr_logv_mat <- create_xptr("log_v_pdf_comp_mat")
G$r <-  sample.r(G$wh,G$mh,sig)   # 1. r_i ~ p(r_i | ...), i=1..n
G$mh <- sample.mh(G$wh,G$r,sig)   # 2. m_h ~ p(m_h | ...), h=1..H
sample.r <- function(wh,mh,sig)
{ ## samle allocation indicators
r <- rep(0,n)
for(i in 1:n){
ph <-   dnorm(y[i],m=mh,sd=sig)*wh # likelihood   * prior
## p(yi | ri=h) * w_h
r[i] <- sample(1:H,1,prob=ph/sum(ph))
}
return(r)
}
G$r <-  sample.r(G$wh,G$mh,sig)   # 1. r_i ~ p(r_i | ...), i=1..n
G$mh <- sample.mh(G$wh,G$r,sig)   # 2. m_h ~ p(m_h | ...), h=1..H
G$r
## sample vh ~ p(vh | ...)
## returns: wh
#r=c
n_k<- table(r)
lh<-  rep(0,H)
n_k
r = G$r
r
## sample vh ~ p(vh | ...)
## returns: wh
#r=c
n_k<- table(r)
lh<-  rep(0,H)
n_k
lh
lh<-  rep(0,H)
H
#sample v
v_s = ru_rcpp(logf = ptr_logv_mat,alpha=alpha, sigma=sigma,H=H,k = length(n_k), nk_vec=n_k,Cnk_mat=mat, n=1,  d=1, init=1)
#sample lk
lk <- sample_lk_mat(n_k,v_s$sim_vals[1],sigma,H,mat)
lh[c(as.numeric(c(names(n_k))))]= lk
vh <- rep(0,H)  # initialize
W_h <- rep(0,H)
P_h<-  rep(0,H)
p_vec<- n_k - lk*sigma
W_h<- rdirichlet(1,c(p_vec, sum(lk)*sigma + alpha))
### R
alpha_post<- alpha + sum(lk)*sigma
Uv<- rgamma(1,alpha_post/sigma,alpha_post/sigma)
U<- (Uv)^(1/sigma)
x.rlap <- rlaptrans(H, lt.temp_st_pdf, c=alpha_post/(sigma*H), sigma, k=U)
R_h<- x.rlap /sum(x.rlap)
P_h[c(as.numeric(c(names(n_k))))]<- W_h[1:length(n_k)] + W_h[length(n_k)]* R_h[1:length(n_k)]
P_h[-c(as.numeric(c(names(n_k))))] <-  W_h[length(n_k)]* R_h[(length(n_k)+1):H]
P_h
## sample vh ~ p(vh | ...)
## returns: wh
#r=c
n_k<- table(r)
lh<-  rep(0,H)
#sample v
v_s = ru_rcpp(logf = ptr_logv_mat,alpha=alpha, sigma=sigma,H=H,k = length(n_k), nk_vec=n_k,Cnk_mat=mat, n=1,  d=1, init=1)
n_k
lh<-  rep(0,H)
lh
#sample lk
lk <- sample_lk_mat(n_k,v_s$sim_vals[1],sigma,H,mat)
lk
lh[c(as.numeric(c(names(n_k))))]= lk
lh
vh <- rep(0,H)  # initialize
W_h <- rep(0,H)
P_h<-  rep(0,H)
p_vec<- n_k - lk*sigma
W_h<- rdirichlet(1,c(p_vec, sum(lk)*sigma + alpha))
W_h
dim(W_h)
length(lk)
### R
alpha_post<- alpha + sum(lk)*sigma
Uv<- rgamma(1,alpha_post/sigma,alpha_post/sigma)
U<- (Uv)^(1/sigma)
x.rlap <- rlaptrans(H, lt.temp_st_pdf, c=alpha_post/(sigma*H), sigma, k=U)
R_h<- x.rlap /sum(x.rlap)
dim(R_h)
length(R_h)
W_h[length(n_k)]
W_h[length(n_k)+1]
W_h[17]
getwd()
