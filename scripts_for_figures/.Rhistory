g0 <- 0.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
for (i in 1:10000){
C0_array[i,,] <- rwishart(2 * g0, 0.5 * chol2inv(chol(G0)))$W  #from package 'bayesm'
sig <- rwishart(2 * c0, 0.5 * chol2inv(chol(C0_array[i,,])))  #attention: rwishart(nu,v)(Rossi)=> nu=2*c0,v=0.5*C0, wishart(c0,C0) (FS)
Sigma_array[i, , ] <- sig$IW
Inv_Sigma_array[i, , ] <- sig$W
}
Sig_mean_1 = apply(Sigma_array, c(2,3), mean)
C0_mean_1 = apply(C0_array, c(2,3), mean)
Inv_Sigma_mean_1 = apply(Inv_Sigma_array, c(2,3), mean)
Sig_mean_1
C0_mean_1
Inv_Sigma_mean_1
det(Sig_mean_1)
?determinant(Sig_mean)
det(Sig_mean_1)
det(Sig_mean_20)
det(Sig_mean_5)
ds_list<- c("~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_20.RData","~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_200.RData",
"~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_2000.RData","~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_20000.RData")
data =  loadRData(ds_list[4])
y <- as.matrix(data$y)
## read dimensions of data:
r <- length(y[1, ])
N <- length(y[, 1])
M = 10000
Sigma_array = array(0, dim = c(M, r, r))
Inv_Sigma_array = array(0, dim = c(M, r, r))
C0_array = array(0, dim = c(M, r, r))
C0_j <- matrix(0, r, r)
Sigma_j <- matrix(0, r, r)
Sigma_prior<- list()
Sigma_prior$coef = 1
R <- apply(y, 2, function(x) diff(range(x)))
R
# prior on Sigma_k [modification for sensitivity analysis with R/5, R/10, R/20]
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
for (i in 1:10000){
C0_array[i,,] <- rwishart(2 * g0, 0.5 * chol2inv(chol(G0)))$W  #from package 'bayesm'
sig <- rwishart(2 * c0, 0.5 * chol2inv(chol(C0_array[i,,])))  #attention: rwishart(nu,v)(Rossi)=> nu=2*c0,v=0.5*C0, wishart(c0,C0) (FS)
Sigma_array[i, , ] <- sig$IW
Inv_Sigma_array[i, , ] <- sig$W
}
Sig_mean_1 = apply(Sigma_array, c(2,3), mean)
C0_mean_1 = apply(C0_array, c(2,3), mean)
Inv_Sigma_mean_1 = apply(Inv_Sigma_array, c(2,3), mean)
Sig_mean_1
C0_mean_1
Sigma_prior$coef = 1/5
## prior on Sigma_k [modification for sensitivity analysis with R/5, R/10, R/20]
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
for (i in 1:10000){
C0_array[i,,] <- rwishart(2 * g0, 0.5 * chol2inv(chol(G0)))$W  #from package 'bayesm'
sig <- rwishart(2 * c0, 0.5 * chol2inv(chol(C0_array[i,,])))  #attention: rwishart(nu,v)(Rossi)=> nu=2*c0,v=0.5*C0, wishart(c0,C0) (FS)
Sigma_array[i, , ] <- sig$IW
Inv_Sigma_array[i, , ] <- sig$W
}
Sig_mean_1 = apply(Sigma_array, c(2,3), mean)
C0_mean_1 = apply(C0_array, c(2,3), mean)
Inv_Sigma_mean_1 = apply(Inv_Sigma_array, c(2,3), mean)
Sig_mean_1
Sigma_prior$coef = 1/20
r <- length(y[1, ])
N <- length(y[, 1])
M = 10000
Sigma_array = array(0, dim = c(M, r, r))
Inv_Sigma_array = array(0, dim = c(M, r, r))
C0_array = array(0, dim = c(M, r, r))
C0_j <- matrix(0, r, r)
Sigma_j <- matrix(0, r, r)
Sigma_prior<- list()
Sigma_prior$coef = 1/20
R <- apply(y, 2, function(x) diff(range(x)))
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
for (i in 1:10000){
C0_array[i,,] <- rwishart(2 * g0, 0.5 * chol2inv(chol(G0)))$W  #from package 'bayesm'
sig <- rwishart(2 * c0, 0.5 * chol2inv(chol(C0_array[i,,])))  #attention: rwishart(nu,v)(Rossi)=> nu=2*c0,v=0.5*C0, wishart(c0,C0) (FS)
Sigma_array[i, , ] <- sig$IW
Inv_Sigma_array[i, , ] <- sig$W
}
Sig_mean_1 = apply(Sigma_array, c(2,3), mean)
C0_mean_1 = apply(C0_array, c(2,3), mean)
Inv_Sigma_mean_1 = apply(Inv_Sigma_array, c(2,3), mean)
Sig_mean_1
C0_mean_1
Inv_Sigma_mean_1
data =  loadRData(ds_list[4])
y <- as.matrix(data$y)
C0 <- 0.75 * cov(y)
C0
data =  loadRData(ds_list[3])
C0 <- 0.75 * cov(y)
C0
data =  loadRData(ds_list[3])
y <- as.matrix(data$y)
C0 <- 0.75 * cov(y)
C0
data =  loadRData(ds_list[4])
C0 <- 0.75 * cov(y)
y <- as.matrix(data$y)
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
C0
knitr::opts_chunk$set(echo = TRUE)
Mat = compute_Sigma(M=10000, coef_R = 1, y)
compute_Sigma<- function(M, coef_R, y){
r <- length(y[1, ])
N <- length(y[, 1])
Sigma_array = array(0, dim = c(M, r, r))
Inv_Sigma_array = array(0, dim = c(M, r, r))
C0_array = array(0, dim = c(M, r, r))
C0_j <- matrix(0, r, r)
Sigma_j <- matrix(0, r, r)
R <- apply(y, 2, function(x) diff(range(x)))
## prior on Sigma_k [modification for sensitivity analysis with R/5, R/10, R/20]
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
R_mod = R*coef_R
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
for (i in 1:M){
C0_array[i,,] <- rwishart(2 * g0, 0.5 * chol2inv(chol(G0)))$W  #from package 'bayesm'
sig <- rwishart(2 * c0, 0.5 * chol2inv(chol(C0_array[i,,])))  #attention: rwishart(nu,v)(Rossi)=> nu=2*c0,v=0.5*C0, wishart(c0,C0) (FS)
Sigma_array[i, , ] <- sig$IW
Inv_Sigma_array[i, , ] <- sig$W
}
Sig_mean = apply(Sigma_array, c(2,3), mean)
C0_mean = apply(C0_array, c(2,3), mean)
Inv_Sigma_mean = apply(Inv_Sigma_array, c(2,3), mean)
return(list(S=  Sig_mean,C0 = C0_mean, InvS = Inv_Sigma_mean ))
}
Mat = compute_Sigma(M=10000, coef_R = 1, y)
Mat = compute_Sigma(M=10000, coef_R = 1, y)
Mat$S
Mat$S
Mat$C0
Mat$InvS
Mat5 = compute_Sigma(M=10000, coef_R = 1/5, y)
Mat5$S
Mat5$C0
Mat5$InvS
Mat20 = compute_Sigma(M=10000, coef_R = 1/20, y)
Mat20$S
Mat20$C0
Mat20$InvS
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Code_SP_Mix/Random_SpMix.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Code_SP_Mix/Estimation_SpMix.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Code_SP_Mix/Identification_SpMix.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Gibbs_sampling_function.R")
ds_list<- c("~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_20.RData","~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_200.RData",
"~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_2000.RData","~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_20000.RData")
data =  loadRData(ds_list[4])
y <- as.matrix(data$y)
det(Mat20$S)
det(Mat5$S)
det(Mat20$S)
Sigma_prior = NULL
fixedS =NULL
(is.null(Sigma_prior)&is.null(fixedS))
if (is.null(Sigma_prior)){
R_mod = R
}else{
R_mod = R*Sigma_prior$coef
}
if (is.null(Sigma_prior)){
R_mod = R
print(1)
}else{
R_mod = R*Sigma_prior$coef
}
if (is.null(fixedS)){
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
print(1)
}else{
c0 <- 2.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
C0 <- (c0/100)* diag((R_mod^2))
}
if (is.null(fixedS)){
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
print(R_mod)
}else{
c0 <- 2.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
C0 <- (c0/100)* diag((R_mod^2))
}
R
#### sensitivity with a fixed Sigma prior
ds_list_short <- c("~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_20.RData","~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_200.RData",
"~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_2000.RData")
df_sens_fixed <-comparison_sens(ds_list_short, alpha = 0.01,K_ = 10, M_it= 1000 , nburn = 100, coef_R =1, fixedS = TRUE)
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Utils_post.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Code_SP_Mix/Estimation_SpMix.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Gibbs_sampling_function.R")
df_sens_fixed <-comparison_sens(ds_list_short, alpha = 0.01,K_ = 10, M_it= 1000 , nburn = 100, coef_R =1, fixedS = TRUE)
fixS = NULL
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Gibbs_sampling_function.R")
df_sens_fixed <-comparison_sens(ds_list_short, alpha = 0.01,K_ = 10, M_it= 1000 , nburn = 100, coef_R =1, fixS  = TRUE)
df_sens_fixed
df_sens_fixed$line
save(df_sens_fixed, file = "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed1.RData")
plt_fig1(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed1.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1)
df_sens_fixed <-comparison_sens(ds_list_short, alpha = 0.01,K_ = 10, M_it= 20000 , nburn = 10000, coef_R =1, fixS  = TRUE)
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/plt_Fig1_short.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/plt_Fig1_short.R")
save(df_sens_fixed, file = "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed1.RData")
plt_fig1_short(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed1.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1)
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/plt_Fig1_short.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/plt_Fig1_short.R")
plt_fig1_short(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed1.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1)
ds_list_short <- c("~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_20.RData","~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_200.RData",
"~/Documents/GitHub/BNPconsistency/scripts_for_figures/sim_data/GM_3_2000.RData")
alpha = 0.01
K_ = 10
M_it= 20000
nburn = 10000
coef_R =1/5
fixS  = TRUE
pk<- list()
N<- c()
R_h <- c()
W_non_sorted <- list()
W <- list()
Mu_mat <- list()
S_mat<- list()
Sigma_prior<- list()
Sigma_prior$coef = coef_R
e0=alpha
K=K_
M=M_it
burnin=nburn
Sigma_prior= Sigma_prior
fixedS = fixS
fixedS
Sigma_prior
e0
print(seed_)
y <- as.matrix(data$y)
#Mmax <- M + burnin
## read dimensions of data:
r <- length(y[1, ])
N <- length(y[, 1])
r
N
## Dirichlet parameter for the mixture weights
## variance of the normal proposal for the MH step for estimating e0
c_proposal <- 0.8
R <- apply(y, 2, function(x) diff(range(x)))
R
if (is.null(Sigma_prior)){
R_mod = R
}else{
R_mod = R*Sigma_prior$coef
}
R_mod
if (is.null(fixedS)){
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
}else{
c0 <- 2.5 + (r - 1)/2
R_mod = R*Sigma_prior$coef
C0 <- (c0/100)* diag((R_mod^2))
}
c)
c0
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Gibbs_sampling_function.R")
if (is.null(fixedS)){
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
}else{
c0 <- 2.5 + (r - 1)/2
C0 <- (c0/100)* diag((R_mod^2))
}
Co0
C0
(is.null(fixedS))
C0 <- 0.75 * cov(y)
C0
if (is.null(fixedS)){
c0 <- 2.5 + (r - 1)/2
C0 <- 0.75 * cov(y)
g0 <- 0.5 + (r - 1)/2
G0 <- 100 * g0/c0 * diag((1/R_mod^2))
}else{
c0 <- 2.5 + (r - 1)/2
C0 <- (c0/100)* diag((R_mod^2))
}
C0
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Code_SP_Mix/Estimation_SpMix.R")
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Gibbs_sampling_function.R")
df_sens_fixed_5 <-comparison_sens(ds_list_short, alpha = 0.01,K_ = 10, M_it= 20000 , nburn = 10000, coef_R =1/5, fixS  = TRUE)
save(df_sens_fixed_5, file = "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed5.RData")
plt_fig1_short(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed5.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1/5)
df_sens_fixed_5$line$Rh
df_sens_fixed$line$Rh
df_sens_fixed_20 <-comparison_sens(ds_list_short, alpha = 0.01,K_ = 10, M_it= 20000 , nburn = 10000, coef_R =1/20, fixS  = TRUE)
save(df_sens_fixed_20, file = "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed20.RData")
plt_fig1_short(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed20.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1/20)
plt_fig1_short(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed20.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1/20)
plt_fig1_short(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed20.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1/20)
plt_fig1_short(input_file= "~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_fixed20.RData", c_vec =c(0.1, 0.5, 1, 2) , fig_path= "~/Documents/GitHub/BNPconsistency/figures/Figure_sens/" ,Sigma_coef = 1/20)
df_sens_fixed_20$line$Rh
fig_df_s =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_ds20.RData")
rm(list=ls())
setwd("~/Documents/GitHub/BNPconsistency/scripts_for_figures")
require(e1071)
require(mclust)
require(MASS)
require(bayesm)
require(MCMCpack)
require(mvtnorm)
require(Runuran)
require(flexclust)
library(gridExtra)
library(cowplot)
library(ggplot2)
library(latex2exp)
require(tidyr)
library(dplyr)
library(JuliaCall)
library(viridis)
source("~/Documents/GitHub/BNPconsistency/scripts_for_figures/Utils_post.R")
fig_df_s =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_ds20.RData")
fig_df=  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens2 2.RData")
fig_df_mut <- fig_df$line%>%group_by(Process_type,N)%>%mutate(pkn =density/sum(density))
fig_df_mut_s <- fig_df_s$line%>%group_by(Process_type,N)%>%mutate(pkn =density/sum(density))
K_ = max(fig_df_mut$K)
n_vec = c( fig_df_mut$N[1],fig_df_mut$N[(max(fig_df_mut$K)+1)],fig_df_mut$N[(2*max(fig_df_mut$K)+1)],fig_df_mut$N[(3*max(fig_df_mut$K)+1)])
alpha_val = fig_df_mut$alpha[1]
julia <- julia_setup()
julia_library("GibbsTypePriors")
julia_assign("K_bound", K_)
julia_assign("N1", n_vec[1])
julia_assign("N2", n_vec[2])
julia_assign("N3", n_vec[3])
julia_assign("N4", n_vec[4])
# alpha = e0*K
julia_assign("alpha", fig_df$line$alpha[1]*K_)
print( fig_df$line$alpha[1]*K_)
df_prior = tibble(K= 1:K_,
Pkn_1 = round(julia_eval("Pkn_Dirichlet_mult.(1:K_bound,N1, K_bound, alpha)"),3),
Pkn_2= round(julia_eval("Pkn_Dirichlet_mult.(1:K_bound,N2, K_bound, alpha)"),3),
Pkn_3 = round(julia_eval("Pkn_Dirichlet_mult.(1:K_bound,N3, K_bound, alpha)"),3),
Pkn_4 = round(julia_eval("Pkn_Dirichlet_mult.(1:K_bound,N4, K_bound, alpha)"),3))%>% gather(Process_type, pkn,Pkn_1:Pkn_4)
df_prior$Type =rep("Prior", dim(df_prior)[1])
fig_df_mut$Type= rep("Posterior", dim(fig_df_mut)[1])
fig_df_mut
fig_df_mut_s
fig_df_mut$density[1:40]
#replace
fig_df_mut$density[1:10] =
df_merged = rbind(df_prior,fig_df_mut[, c("K","Process_type", "pkn", "Type")] )
fig_df_mut$density[1:10]
fig_df_mut$density[1:10,]
fig_df_mut$density[1:10]
fig_df_mut$density
fig_df_mut_s$density
fig_df_mut <- fig_df$line%>%group_by(Process_type,N)%>%mutate(pkn =density/sum(density))
K_ = max(fig_df_mut$K)
n_vec = c( fig_df_mut$N[1],fig_df_mut$N[(max(fig_df_mut$K)+1)],fig_df_mut$N[(2*max(fig_df_mut$K)+1)],fig_df_mut$N[(3*max(fig_df_mut$K)+1)])
alpha_val = fig_df_mut$alpha[1]
df_prior$Type =rep("Prior", dim(df_prior)[1])
fig_df_mut$Type= rep("Posterior", dim(fig_df_mut)[1])
fig_df_mut$density[1:10]
fig_df_mut_s$density[1:10]
head(fig_df_mut)
head(fig_df_mut_s)
fig_df_mut$density[1:10] = fig_df_mut_s$density[1:10]
fig_df_mut$Rh[1:10] = fig_df_mut_s$Rh[1:10]
fig_df_mut$pkn[1:10] = fig_df_mut_s$pkn[1:10]
df_merged = rbind(df_prior,fig_df_mut[, c("K","Process_type", "pkn", "Type")] )
pkn.labs<- c("Pkn_1","Pkn_2","Pkn_3","Pkn_4")
names(pkn.labs) <- c(paste0("n = ", fig_df_mut$N[1]),paste0("n = ", fig_df_mut$N[max(fig_df_mut$K)+1]),paste0("n = ", fig_df_mut$N[(2*max(fig_df_mut$K)+1)]),paste0("n = ", fig_df_mut$N[(3*max(fig_df_mut$K)+1)]))
pkn_names <- as_labeller(
c(`Pkn_1` = paste0("n = ", fig_df_mut$N[1]), `Pkn_2` = paste0("n = ", fig_df_mut$N[max(fig_df_mut$K)+1]),`Pkn_3` = paste0("n = ", fig_df_mut$N[(2*max(fig_df_mut$K)+1)]),`Pkn_4` = paste0("n = ", fig_df_mut$N[(3*max(fig_df_mut$K)+1)])))
p_h<- ggplot(df_merged, aes(K,pkn,color =Process_type))+geom_bar(aes(linetype=Type),size = 0.7, stat="identity",alpha =0.0, position = "identity")+
geom_vline(xintercept=3,  linetype="dashed")+ylab("Density")+xlab(TeX('$K_n$'))+
ggtitle(TeX(sprintf('Posterior distribution for the number of clusters for $\\alpha =%.3f$,$\\n =(%2.f,%2.f,%2.f, %2.f) $ ',fig_df_mut$alpha[1],fig_df_mut$N[1],fig_df_mut$N[(max(fig_df_mut$K)+1)],fig_df_mut$N[(2*max(fig_df_mut$K)+1)],fig_df_mut$N[(3*max(fig_df_mut$K)+1)])))+
theme_minimal()+ scale_color_viridis(discrete= "TRUE", begin = 0, end = 0.9,option = "D", name = TeX(sprintf('$n$')) ,labels=unname(TeX(c(sprintf('$n$=%3.f',fig_df_mut$N[1]),sprintf('$n$=%3.f',fig_df_mut$N[(max(fig_df_mut$K)+1)]),sprintf('$n$=%3.f',fig_df_mut$N[(2*max(fig_df_mut$K)+1)]),sprintf('$n$=%3.f',fig_df_mut$N[(3*max(fig_df_mut$K)+1)])))))+
scale_x_continuous(breaks = c(1,3,7,10), limits = c(0,11))+
scale_linetype_manual(name = "Distribution",values = c(1, 2),guide = guide_legend(override.aes = list(linetype = c(1, 2),color = "black") ) )+
facet_wrap(~Process_type,labeller = pkn_names)
p_h
pdf(paste0(fig_path,"Figure1_alpha_",fig_df_mut$alpha[1],"_2.pdf" ))
fig_path = "~/Documents/GitHub/BNPconsistency/figures/Figure_sensitivity/"
pdf(paste0(fig_path,"Figure1_alpha_",fig_df_mut$alpha[1],"R_coef_",Sigma_coef,"_2.pdf" ))
Sigma_coef = 0.05
pdf(paste0(fig_path,"Figure1_alpha_",fig_df_mut$alpha[1],"R_coef_",Sigma_coef,"_2.pdf" ))
plot(p_h)
dev.off()
p_h2 <- ggplot(df_merged, aes(K,pkn,color =Process_type))+geom_bar(aes(linetype=Type),size = 0.7, stat="identity",alpha =0.0, position = "identity")+
geom_vline(xintercept=3,  linetype="dashed")+ylab("Density")+xlab(TeX('$K_n$'))+
#ggtitle(TeX(sprintf('Posterior distribution for the number of clusters for $\\alpha =%.3f$,$\\N =(%2.f,%2.f,%2.f, %2.f) $ ',fig_df_mut$alpha[1],fig_df_mut$N[1],fig_df_mut$N[(max(fig_df_mut$K)+1)],fig_df_mut$N[(2*max(fig_df_mut$K)+1)],fig_df_mut$N[(3*max(fig_df_mut$K)+1)])))+
theme_minimal()+ scale_color_viridis(discrete= "TRUE", begin = 0, end = 0.9,option = "D", name = TeX(sprintf('$n$')) ,labels=unname(TeX(c(sprintf('$n$ = %3.f',fig_df_mut$N[1]),sprintf('$n$ = %3.f',fig_df_mut$N[(max(fig_df_mut$K)+1)]),sprintf('$n$ = %3.f',fig_df_mut$N[(2*max(fig_df_mut$K)+1)]),sprintf('$n$ = %3.f',fig_df_mut$N[(3*max(fig_df_mut$K)+1)])))))+
scale_x_continuous(breaks = c(1,3,7,10), limits = c(0,11))+
scale_linetype_manual(name = "Distribution",values = c(1, 2),guide = guide_legend(override.aes = list(linetype = c(1, 2),color = "black") ) )+
facet_wrap(~Process_type,labeller = pkn_names)
p_h2
pdf(paste0(fig_path,"Figure1_alpha_",fig_df_mut$alpha[1],"R_coef_",Sigma_coef,"_2_.pdf" ))
plot(p_h2)
dev.off()
fig_df_mut_s
pkn.labs<- c("W_1","W_2","W_3","W_4")
names(pkn.labs) <- c(paste0("n = ", n_vec[1]),paste0("n = ",n_vec[2]),paste0("n = ", n_vec[3]),paste0("n = ", n_vec[4]))
pkn_names <- as_labeller(
c(`W_1` = paste0("n = ", n_vec[1]), `W_2` = paste0("n = ", n_vec[2]),`W_3` = paste0("n = ", n_vec[3]),`W_4` = paste0("n = ", n_vec[4])))
weights_fig <-fig_df$weights
weights_fig$n <-as.factor(weights_fig$W_val)
weights_fig_thin<- weights_fig%>%  group_by(K,n, W_,W_val) %>%  filter(row_number() %% 5 == 1)
weights_fig_s <- fig_df_s$weights
dim(weights_fig)
dim(weights_fig_s)
dim(weights_fig)
weights_fig$n <-as.factor(weights_fig$W_val)
weights_fig_thin<- weights_fig%>%  group_by(K,n, W_,W_val) %>%  filter(row_number() %% 5 == 1)
dim(weights_fig_thin)
head(weights_fig_s)
head(weights_fig)
weights_fig_s$n <-as.factor(weights_fig_s$W_val)
weights_fig_thin_s<- weights_fig_s%>%  group_by(K, W_,W_val) %>%  filter(row_number() %% 5 == 1)
weights_fig_thin<- weights_fig%>%  group_by(K,n, W_,W_val) %>%  filter(row_number() %% 5 == 1)
weights_fig_thin_s<- weights_fig_s%>%  group_by(K,n, W_,W_val) %>%  filter(row_number() %% 5 == 1)
weights_fig_thin
dim(weights_fig_thin_s)
weights_fig_thin_s[80000,]
weights_fig_thin_s[80001,]
weights_fig_thin[8000,]
weights_fig_thin[order(weights_fig_thin$n,weights_fig_thin$it,weights_fig_thin$K)]
weights_fig_thin[order(weights_fig_thin$n,weights_fig_thin$it,weights_fig_thin$K),]
A = weights_fig_thin[order(weights_fig_thin$n,weights_fig_thin$it,weights_fig_thin$K),]
A[80000,]
A[80001,]
weights_fig_thin[order(weights_fig_thin$n,weights_fig_thin$it,weights_fig_thin$K),] = weights_fig_thin_s[order(weights_fig_thin_s$it, weights_fig_thin_s$K),]
weights_fig_thin<- weights_fig%>%  group_by(K,n, W_,W_val) %>%  filter(row_number() %% 5 == 1)
weights_fig_thin_s<- weights_fig_s%>%  group_by(K,n, W_,W_val) %>%  filter(row_number() %% 5 == 1)
Weights = weights_fig_thin[order(weights_fig_thin$n,weights_fig_thin$it,weights_fig_thin$K),]
Weights[1:80000,] = weights_fig_thin_s[order(weights_fig_thin_s$it, weights_fig_thin_s$K),]
pw <- ggplot(Weights, aes(x=K, y=weights, group =K, fill = n )) + ylab("Weights")+xlab(TeX('$K_n$'))+scale_x_continuous(breaks = c(1,3,7,10), limits = c(0,11))+
geom_boxplot(alpha=0.5) +scale_fill_viridis(discrete= "TRUE", begin = 0, end = 0.9,option = "D", name = TeX(sprintf('$n$')) ,labels=unname(TeX(c(sprintf('$n$ = %3.f',n_vec[1]),sprintf('$n$ = %3.f',n_vec[2]),sprintf('$n$ = %3.f',n_vec[3]),sprintf('$n$ = %3.f',n_vec[4])))))+
ggtitle(TeX(sprintf('Posterior distribution of the component weights $\\alpha =%.3f$,$\\N =(%2.f,%2.f,%2.f, %2.f) $ ',fig_df_mut$alpha[1],n_vec[1],n_vec[2],n_vec[3],n_vec[4])))+
theme_minimal()+  ylim(0,0.65)+facet_wrap(~W_,labeller = pkn_names)
pw
pdf(paste0(fig_path,"Figure1_alpha_",fig_df_mut$alpha[1],"R_coef_",Sigma_coef,"_3.pdf" ))
plot(pw)
dev.off()
pw2 <- ggplot(Weights, aes(x=K, y=weights, group =K, fill = n )) + ylab("Weights")+xlab(TeX('$K_n$'))+scale_x_continuous(breaks = c(1,3,7,10), limits = c(0,11))+
geom_boxplot(alpha=0.5) +scale_fill_viridis(discrete= "TRUE", begin = 0, end = 0.9,option = "D", name = TeX(sprintf('$n$')) ,labels=unname(TeX(c(sprintf('$n$ = %3.f',n_vec[1]),sprintf('$n$ = %3.f',n_vec[2]),sprintf('$n$ = %3.f',n_vec[3]),sprintf('$n$ = %3.f',n_vec[4])))))+
#ggtitle(TeX(sprintf('Posterior distribution of the component weights $\\alpha =%.3f$,$\\N =(%2.f,%2.f,%2.f, %2.f) $ ',fig_df_mut$alpha[1],n_vec[1],n_vec[2],n_vec[3],n_vec[4])))+
theme_minimal()+  ylim(0,0.65)+facet_wrap(~W_,labeller = pkn_names)
pw2
pdf(paste0(fig_path,"Figure1_alpha_",fig_df_mut$alpha[1],"R_coef_",Sigma_coef,"_3_.pdf" ))
plot(pw2)
dev.off()
#Convergence results
df_1 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens1.RData")
#Convergence results
df_1 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens1.RData")
#Convergence results
df_1 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens1.RData")
#Convergence results
df_1 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens1.RData")
df_2 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens2 2.RData")
df_3 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens3.RData")
df_4 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens4.RData")
df_2$line$Rh
Rh_table = tibble(K= 1:40,Rh_2 = df_2$line$Rh, Rh_3 = df_3$line$Rh , Rh_4 = df_4$line$Rh)
df_fix  =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_ds20.RData")
df_fix  =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens_ds20.RData")
#Convergence results
df_1 =  loadRData("~/Documents/GitHub/BNPconsistency/saves_for_figures/cmp_fig_sens1.RData")
Rh2 = df_2$line$Rh
Rh2
Rh2[1:10] = df_fix$line$Rh
Rh_table = tibble(K= 1:40,Rh_1 = df_1$line$Rh, Rh_2 = Rh2, Rh_3 = df_3$line$Rh , Rh_4 = df_4$line$Rh)
Rh_table
Rh_table[20:30,]
Rh_table[30:40,]
dim(Rh_table)
Rh_table = tibble(K= 1:40,Rh_1 = df_1$line$Rh, Rh_2 = Rh2, Rh_3 = df_3$line$Rh , Rh_4 = df_4$line$Rh)
getwd()
write.table(Rh_table, file =paste0(fig_path,"Convergence_sensitivity_analysis.csv"), sep = ",", col.names = NA,qmethod = "double")
fig_path
df_2$hist$Rh
df_1$line
